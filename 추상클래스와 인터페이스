추상(Abstract) : 구체적으로 완성되지 않았다는 의미(미완성)

추상 클래스(Abstract Class)
  - 미완성 클래스 : 미완성 메서드들 포함
  - body가 구현되지 않은 미완성 메서드를 포함하고 있다는 의미
  - 내용은 구현하지 않고, 전체적인 틀만 갖춘 상황
  - 상속받은 클래스에서 용도에 맞게 구체적으로 구현해서 완성
  - 추상 메서드를 포함하고 있다는 것을 제외하고는 일반 클래스와 동일(생성, 멤버필드, 메서드 포함)

추상 클래스 생성 방법
  - 실제 클래스들의 공통되는 필드와 메서드를 정의
    - 공통되는 규격을 정해 놓는 것
    - 상속받는 클래스에서 반드시 이 규격대로 구현하라는 의미
    - 규격 외 부분은 각 클래스의 특성에 맞춰 추가
    - 상속을 위해 만들어진 클래스(단독 객체 생성 안됨)

추상 클래스 용도
  - 실체 클래스들의 공통된 필드와 메서드의 이름을 통일할 목적
    - 실체 클래스 설계자가 여러 사람인 경우
    - 실체 클래스마다 필드와 메서드가 제각기 다른 이름을 가질 수 있는 경우
  - 실체 클래스를 작성할 때 시간 절약
    - 실체 클래스 추가적인 필드와 메서드만 선언
  - 실체 클래스의 설계 규격을 만들고자 할 때
    - 실체 클래스가 가져야할 필드와 메서드를 추상 클래스에 미리 정의
    - 실체 클래스는 추상 클래스를 무조건 상속 받아 작성

추상 클래스 목적
  - 서브 클래스에서 필요로 하는 대부분의 기능 구현해두고, 서브 클래스가 상속 받아 활용할 수 있도록 하되, 
    서브 클래스에서 반드시 구현해야 하는 기능만을 추상 메서드로 선언하며, 서브 클래스에서 자신에 맞게 구현하도록 하는 것

추상 클래스 선언
  - 클래스 선언에 abstract 키워드 사용
  - new 연산자로 객체 생성하지 못하고, 상속을 통해 자식 클래스만 생성 가능
  - public abstract class 클래스명 {
    // 필드
    // 생성자
    // 메서드
    }


추상 메서드 (Abstract Method)
  - 선언은 되어 있으나 body가 정의되지 않은 메서드
  - abstract 키워드 선언
  - public abstract String getName();

추상 메서드와 오버라이딩 (메서드 재정의)
  - 메서드 이름은 동일하지만, 실행 내용이 실체 클래스마다 다른 경우 추상 메서드로 선언
  - 구현 방법
    - 추상 클래스에서 메서드 선언부만 작성 (추상메서드)
    - 실체 클래스에서 메서드의 실행 내용 작성 (오버라이딩)


인터페이스 (Interface)
  - 객체의 사용 방법을 정리한 타입
  - 클래스들이 구현해야 하는 동작을 지정하는 데 사용되는 추상형
  - 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하기 위해 사용
  - 추상 클래스와 유사
  - 기본 설계도 의미

인터페이스 목적
  - 객체의 기능을 모두 공개한 표준화 문서와 같은 것으로 개발자에게 인터페이스를 구현하는 클래스의 목적에 따라
    인터페이스의 모든 추상 메서드를 작성하도록 하는 것

인터페이스 특징
  - 인터페이스는 객체 생성 불가 | 구현되지 않은 추상 메서드를 가지고 있기 때문
  - 객체를 생성할 수 없기 때문에 > 생성자를 가질 수 없음
  - 인터페이스끼리 상속 가능
  - 인터페이스를 상속 받아서 클래스를 구현하면 인터페이스의 모든 추상 메서드를 구현해야 함

인터페이스 작성 과정
  1. 선언
    - interface 키워드로 선언
  2. 구현 
    - 클래스에서 인터페이스 구현
    - implements 키워드로 명시
    - public 클래스명 implement 인터페이스명
  3. 사용
    - 인터페이스에 구현된 클래스의 객체에 대입
    - 인터페이스 변수 = new 클래스();
    - ISmartPhone isp = new SPhone();
    - isp.sendCall();

인터페이스 구성 멤버
  - 상수 필드
  - 추상 메서드
  - 디폴트 메서드
  - private 메서드
  - static 메서드

상수 필드
  - 인터페이스는 런타임시 데이터를 저장할 수 있는 필드를 선언할 수 없지만 상수 필드 선언 가능
    - 인터페이스에 고정된 값으로 런타임 시 데이터를 바꿀 수 없음
  - 인터페이스에 선언된 필드는 모두 public static final
    - 자동으로 컴파일 과정에서 붙음
  - 인터페이스는 인스턴스 필드 가질 수 없음

추상 메서드 선언
  - 선언은 되어 있으나 body가 정의되지 않은 인터페이스에서 선언된 추상 메서드는 모두 public abstract
    - 생략하더라도 컴파일 과정에 자동으로 붙게 됨

디폴트 메서드
  - 실행 블록을 가지고 있는 메서드
  - default 키워드 반드시 붙임
  - 기본적으로 public 접근 제한 | 생략하더라도 컴파일 과정에서 자동으로 붙임

static 메서드
  - 객체 없이 인터페이스만으로도 호출 가능한 메서드
  - static 키워드 사용
  - 실행 블록을 가지고 있는 메서드

다중 인터페이스 구현 클래스
  - 여러 개의 인터페이스를 구현한 클래스
  - public class 구현클래스명 implements 인터페이스 A, 인터페이스 B {}

JAVA에서는 인터페이스를 구현하는 클래스의 객체를 해당 인터페이스 유형의 변수에 할당하면 다형성을 활용
    > 객체가 수행하는 방식 (클래스의 구현 세부 정보) 보다는 객체가 수행할 수 있는 작업(인터페이스에 정의된 메서드)에 중점을 둠

    1. 다형성 활용
      - 인터페이스의 유형으로 사용하면 코드가 해당 인터페이스를 구현하는 모든 개체와 함께 작동 가능
      - 더욱 유연하고 확장 가능해짐
    2. 디커플링
      - 특정 구현에서 코드 분리
      - 구현을 교체하거나 런타임 시 다른 구현을 사용하는 것이 쉬워짐
    3. 코드 명확성 및 유지 관리
      - 특정 구현 세부 사항보다는 개체가 수행할 수 있는 작업(동작)에 초점을 맞추기 때문에 코드를 더 쉽게 이해하고 유지 관리 가능
    
  
    
