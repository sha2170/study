Stack
  - 후입선출(LIFO)
  - 마지막에 추가된 요소가 가장 먼저 제거되는 구조
  - 현대 Java에서는 Deque 인터페이스의 Arraydeque 클래스 사용을 권장함
  - 주요 메서드 (ArrayDeque) 사용 시
    1. push(e) : 스택의 상단에 요소 추가
    2. pop() : 스택의 상단에서 요소를 제거하고 그 요소를 반환
    3. peek() : 스택의 상단에 있는 요소를 반환하지만, 제거하지는 않음
    4. isFull() /  isEmpty() / size()
  - 마지막에 들어온 요소를 먼저 처리해야하는 경우에 사용
    - 웹 브라우저 뒤로가기, Ctrl+Z, 함수 호출 스택, 깊이 우선 탐색(DFS), 재귀호출 등 추적 알고리즘

Queue
  - 선입선출(FIFO), 순차적 자료구조
  - 먼저 추가된 요소가 먼저 제거되는 구조
  - 주로 데이터가 처리되기를 기다리는 대기열을 관리할 때 사용
  - 주요 메서드
    1. add(e) : 요소 추가, 공간이 부족하면 예외를 throw
    2. offer(e) : 요소 추가, 공간이 부족하면 false를 반환
    3. remove() : 첫 번째 요소를 제거하고 반환, 큐가 비어있으면 예외를 throw
    4. poll() : 첫 번째 요소를 제거하고 반환, 큐가 비어있으면 null을 반환
    5. element() : 첫 번째 요소를 반환, 큐가 비어있으면 예외를 throw
    6. peek() : 첫 번째 요소를 반환, 큐가 비어있으면 null을 반환
  - 구현체
    - LinkedList
    - PriorityQueue
    - ArrayDeque
  - 활용 사례
    - 멀티스레드 환경의 작업 큐
    - 이벤트 처리 시스템
    - 메시지 큐 시스템
  - 잘 활용되지 않는 이유와 대안
    - 성능 이슈 : 일부 큐 구현클래스가 큰 데이터세트나 고성능이 요구되는 환경에서 성능이슈
      - LinkedList => ConcurrentLinkedQueue나 ArrayDeque와 같이 성능이 더 최적화된 구현체를 사용하는 것이 좋음
    - 동시성 문제
    - FIFO 정책만 지원하기 때문에 우선순위 처리 지원이 안됨 -> 우선순위 큐나 외부 라이브러리 활용

Deque(Double-Ended Queue)
  - 양방향 큐
  - 큐의 양쪽 끝에서 추가/제거(유연성)
  - Stack과 Queue 기능을 모두 포함
  - FIFO, LIFO 둘 다 사용 가능
  - LinkedList, ArrayDeque 구현체
  - 멀티스레스 환경에서 사용될 수 있는 concurrentLinkedDeque도 제공
  - 동적 배열을 기반
  - 일반적인 스택이나 큐로 사용될 때 높은 성능을 제공함
  - 주요 메서드
    1. addFirst(E e) / offerFirst(E e) : 덱의 앞쪽에 요소 추가
    2. addLast(E e ) / offerLast(E e) : 덱의 뒤쪽에 요소 추가
    3. removeFirst() / pollFirst() : 덱 앞쪽에서 첫 번째 요소를 제거하고 반환
    4. removeLast() / pollLast() : 덱 뒤쪽에서 마지막 요소를 제거하고 반환
    5. getFirst() / peekFirst() : 덱의 앞쪽 첫 번째 요소 조회, 요소를 제거하지 않음
    6. getLast() / peekLast() : 덱의 뒤쪽 마지막 요소를 조회, 요소를 제거하지 않음
  - 활용
    - 큐로 사용
    - 스택으로 사용
    - 양방향 큐
  - Java 표준 라이브러리에서 주로 사용되는 구현 클래스
    1. ArrayDeque
      - 스택/큐로 사용하기 적합
      - 내부적 요소의 추가와 제거에 빠른 성능을 제공
      - null 요소를 추가할 수 없음
      - 멀티스레드 환경에서 동기화 처리는 별도로 해야 함
    2. LinkedList
      - List와 Deque 인터페이스를 모두 구현하는 연결리스트 기반의 컬렉션
      - 요소의 추가와 제거가 빈번한 시나리오에서 좋은 성능을 제공
      - null 요소의 추가가 가능
      - 인덱스를 통한 무작위 접근은 ArrayDeque보다 느림
    3. ConcurrentLinkedDeque
      - java.util.concurrent 패키지에 속해있고, Deque 인터페이스의 스레드에 안전한 구현체
      - 멀티스레드 환경에서 고성능을 유지함
      - null 요소 추가할 수 없음
  - 스택과 큐로서의 ArrayDeque
    1. 스택으로 사용 : ArrayDeque은 스택 연산을 지원
      - push() 메서드로 요소를 추가
      - pop() 메서드로 가장 최근에 추가된 요소를 제거
      - peek() 메서드로 스택의 맨 위 요소를 조회
    2. 큐로 사용 : ArrayDeque은 큐 연산을 지원
      - offer() 메서드로 큐의 끝에 요소를 추가
      - poll() 메서드로 큐의 처음 요소 제거
      - peek() 메서드로 큐의 처음 요소를 조회
  - ArrayDeque는 내부적으로 배열을 사용해서 요소를 저장
    - 이 배열은 동적으로 크기가 조정될 수 있음
    - 요소를 추가하거나 제거할 때 배열을 환영(원형)배열처럼 사용해서 효율적인 데이터 관리를 가능하게 함
    - LinkedList오 비교했을 때 더 적은 메모리 오버헤드를 가짐
    - 각 요소는 배열의 인덱스로 직접 접근되고, 노드간의 링크를 위한 추가적인 메모리 할당이 필요하지 않음
    - 성능이 일반적으로 매우 좋음 : 스택이나 큐의 연산(추가, 제거, 조회)의 평균적으로 상수시간(O(1))에 이루어짐
    - 배열의 크기 조정이 필요할 때는 해당 작업에 비례하는 시간이 추가적으로 발생할 수 있음
    - 대부분의 경우 ArrayDeque을 사용해서 스택이나 큐를 구현하는 것은 성능면에서 매우 효율적임

