배열(Array)
  - 여러 개의 데이터를 한꺼번에 다룰 수 있음
  - Object는 아니지만 Reference Value로 취급됨
  - 메모리 상에 연달아 공간을 확보
  - 미리 공간을 확보해놓고 써야 함
  - 한 번 만들어진 공간은 크기 고정
  - 첫 번째 위치만 알면 index로 상대적 위치를 빠르게 찾을 수 있음

-> 미리 몇 개가 필요한지 몰라도 사용 가능, 필요에 따라 크기가 늘어가거나 줄어들면 좋겠다
    = 리스트

java.util.List 인터페이스
  - java 컬렉션프레임워크의 일부 순서가 있는 컬렉션
  - 이 인터페이스를 구현하는 클래스들은 요소들을 특정 순서대로 저장하고 관리 가능, 중복 요소의 저장 허용
  - 특징 1. 순서 유지
          - 요소들은 특정 순서로 유지
          - 각 요소가 리스트 내에서 명확한 위치(index)를 가지고 있음
        2. 중복 요소 허용
          - 같은 값을 가진 요소가 리스트 내에 여러 개 존재할 수 있음
        3. 인덱스를 통한 접근 허용, 메서드 제공
        4. 특정 위치의 요소를 조회, 수정, 추가, 삭제 가능
  - 주요 메서드
    1. add(E e) : 리스트의 끝에 요소를 추가
    2. add(int index, E e) : 지정된 위치에 요소를 추가
    3. get(int index) : 지정된 위치의 요소를 반환
    4. set(int index, E e) : 지정된 위치의 요소를 지정된 요소로 대체
    5. remove(int index) : 지정된 위치의 요소를 제거하고, 그 요소를 반환
    6. size() : 리스트에 있는 요소의 수를 반환
    7. isEmpty() : 리스트가 비어있는지 여부를 반환
    8. clear() : 모든 요소를 제거
    9. contains(Object o) : 리스트가 지정된 요소를 포함하는지 여부를 반환
    10. indexOf(Object o), lastIndexOf(Object o) : 지정된 요소의 인덱스를 반환
  - ArrayList, LinkedList, Vector, Stack 등 여러 구현체
  - 각 구현체는 list 인터페이스의 계약을 따르면서도 내부 구현방식이나 사용 사례에 따라 각각 다른 특성을 가짐

java.util.ArrayList
  - ArrayList는 List 인터페이스를 구현
  - 동적 배열의 개념 기반
  - 배열의 크기를 동적으로 조정할 수 있는 기능 제공
  - 배열을 유연하게 관리할 수 있게 해줌
  - 특징 1. 인덱스 기반 접근
        2. 동적 크기 조정
        3. 타입 안정성 : 제네릭 사용, 특정 타입의 객체만을 저장할 수 있도록 할 수 있음
  - 리스트 중간에 요소를 삽입하거나 제거하는 경우, 뒤따르는 모든 요소들을 이동시켜야 함 -> 배열과 비슷함, 비효율적일 수 있음

java.util.LinkedList
  - List 인터페이스를 구현
  - 이중 연결 리스트를 기반
  - 데이터를 서로 (Link로) 연결
  - 노드(Node)
    - 자료구조에 데이터를 담거나 표현하는 기초적인 단위
    - 특정 값이나 포인터가 될 수 있음
    - LinkedList의 노드는 데이터와 링크 공간으로 만들어지고, 연결리스트를 이루는 작은 단위
  - 자주 사용하는 LinkedList 속성과 메서드
    1. addFirst(E e) : 리스트의 시작 부분에 요소를 삽입
    2. addLast(E e) : 마지막 부분에 요소 추가
    3. getFirst() : 리스트의 첫 번째 요소 반환
    4. getLast() : 리스트의 마지막 요소 반환

ArrayList와 LinkedList의 주요 차이점
  1. 내부 구조
    - ArrayList : 동적 배열 사용
    - LinkedList : 이중 연결 리스트 사용
  2. 요소 접근
    - ArrayList : 인덱스를 통한 빠른 임의 접근 가능 (O(1))
    - LinkedList : 순차 접근이 필요, 인덱스로 접근 시 O(n)의 시간이 소요됨
  3. 요소 추가/삭제
    - ArrayList : 리스트의 끝에 요소를 추가/삭제하는 작업은 빠르지만, 중간에 추가/삭제 시 배열을 재조정해야 하므로 비용이 많이 발생
    - LinkedList : 요소의 추가/삭제가 빠르며, 특히 리스트의 시작 또는 끝에서의 작업이 매우 효율적임
  4. 메모리 사용
    - ArrayList : 고정 크기의 배열을 사용하므로, 크기 조정 시 추가 메모리가 잠시 필요할 수 있지만, 전반적으로 메모리 사용은 효율적임
    - LinkedList : 각 요소마다 추가적인 메모리(이전 및 다음 요소에 대한 참조)가 필요하므로, 전반적인 메모리 사용이 더 많음
  5. 사용 사례
    - ArrayList : 임의 접근이 빈번하거나, 요소의 추가/삭제가 주로 리스트의 끝에서 일어나는 경우에 적합
    - LinkedList : 요소의 추가/삭제가 리스트의 중간이나 시작,끝에서 자주 발생하며, 순차 접근이 주로 필요한 경우에 적합
