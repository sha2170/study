자료구조
  - 데이터가 구성되는 형태
    - 순서대로 한 줄로 나열 = 선형 자료구조
    - 연관성 있는 것끼리 묶어서 관리 = 비선형 자료구조

정적 자료구조(Static Data Structures)
  - 프로그램 실행 전에 메모리 크기가 결정되고, 실행동안 그 크기가 변하지 않는 자료구조 -> 즉, 메모리의 크기와 형태가 고정되어 있음
  - 메모리 할당이 미리 이루어지므로, 실행 시간 중에 메모리 관련 계싼이 필요없어 접근 속도가 빠름
  - 프로그램 실행 전에 데이터의 최대 크기를 예측해야 하며, 고정된 크기 때문에 메모리가 낭비되거나 부족할 수 있음
  - 배열(Array) : 생성 시 지정된 크기를 변경할 수 없으며, 그 크기 내에서 데이터를 저장하고 접근함

동적 자료구조(Dynamic Data Structures)
  - 프로그램 실행 도중에도 메모리 크기를 변경할 수 있는 자료구조, 데이터의 추가 및 삭제에 따라 자료구조의 크기가 동적으로 변화함
  - 메모리 사용이 효율적이며, 실행 시간에 따라 자료구조의 크기를 조정할 수 있어 데이터의 추가 및 삭제가 자유로움
  - 메모리의 동적 할당 및 해제로 인한 오버헤드가 발생할 수 있으며, 포인터를 사용하기 때문에 복잡성이 증가할 수 있음
  - 연결 리스트, 스택, 큐 : 필요에 따라 메모리를 할당하거나 해제할 수 있음

선형/비선형으로 데이터가 구성되어 있을 때 CRUD 작업 수행 가능
  1. Create : 새로운 데이터 추가
  2. Read : 저장된 데이터 읽어오기
  3. Update : 새로운 데이터로 변경
  4. Delete : 불필요한 데이터 삭제

알고리즘
  - 데이터에 CRUD 작업을 수행하기 위해 처리하는 방법들 (처리 절차)
  - 데이터의 순서를 바꾸는 방법 -> Sort(bubble sort, insert sort, merge sort, quick sort 등)
  - 원하는 데이터를 찾아내는 방법
  - 추가하거나 읽을 때 순서를 정하는 방법

* 코딩테스트 사이트
  - 백준 
  - 프로그래머스
  - 릿코드
  - 코드트리
  - 카카오테크(기출 해설)

시간 복잡도
  - 주어진 문제를 해결하기 위한 연산 횟수
  - '입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?'
  - 입력되는 데이터(n)의 증가에 따른 성능의 변화를 예측
  - 1억 번의 연산을 1초의 시간으로 간주

시간 복잡도를 신경써야 하는 경우
  - 데이터가 큰 경우
  - 제한 시간이 있는 경우
  - 실시간 처리 요구 사항이 있는 경우

시간 복잡도 유형
  - Big-Ω (빅-오메가) : 하한 점근 - 최선일 때(best case)의 연산 횟수를 나타낸 표기법
  - Big-θ (빅-세타) : 그 둘의 평균 - 보통일 때 (average case)의 연산 횟수
  - Big-O (빅-오) : 상한 점근 - 최악일 때(worst case)의 연산 횟수

빅오 표기법 : 가장 자주 사용되는 표기법
  - 최악의 경우를 고려
  - 코딩테스트에서 사용되는 시간 복잡도 유형
  - 시간 복잡도를 판단할 때는 최악일 때를 염두에 둬야 함
  - 종류
    1. O(1)
    2. O(log n)
    3. O(n)
    4. O(n log n)
    5. O(n^2)
    6. O(2^n)
    7. O(n!)

O(1) : 상수 시간
  - 입력 크기와 관계없이 일정한 시간 내에 작업을 완료하는 알고리즘
  - 삽입, 삭제, 접근 등 특정 연산이 입력 크기와 무관하게 일정한 시간 안에 이루어질 때 사용

O(log n) : 로그 시간
  - 알고리즘의 실행 시간이 입력 크기 n에 대해 로그 함수의 비율로 증가
  - 로그(log)는 일반적으로 밑이 2인 로그를 말하므로, 입력 크기가 2배가 될 때마다 알고리즘의 실행 시간은 한 단계씩만 증가
  - 입력 크기가 커질수록 추가되는 실행 시간이 점점 줄어든다는 것을 의미하며, 따라서 매우 효율적인 알고리즘
  - 특징 1. 효율적
        2. 분할 정복
        3. 반복적 감소

O(n) : 선형 시간
  - 입력 크기 n에 비례하여 시간이 증가하는 알고리즘
  - 데이터의 크기에 따라 선형적으로 시간이 증가하는 작업에 적용
  - 데이터 집합의 모든 요소를 한 번씩 처리해야할 때
  - 배열이나 리스트의 요소를 순차적으로 탐색하거나 처리할 때

O(n log n) : 선형 로그 시간
  - 데이터의 양이 늘어날 수록, 처리 시간이 n과 log n의 곱에 비례하여 증가하는 알고리즘의 성능
  - 이러한 복잡도를 갖는 알고리즘은 대부분 효율적인 정렬 알고리즘
  - 특징 1. 효율적인 정렬 : 데규모 데이터를 처리할 때 매우 효율적
        2. 분할 정복 : 데이터를 더 작은 문제로 나누고, 각각을 정렬한 다음 다시 합치는 과정 포함
        3. 평균과 최악의 경우 성능 : O(n log n) 시간 복잡도를 가진 알고리즘은 평균적으로도, 최악의 경우에도 이 시간 복잡도를 유지함
        4. 대용량 데이터 처리에 적합
  - 병합 정렬, 퀵 정렬, 힙 정렬 등

O(n^2) : 이차 시간
  - 입력 크기 n에 대해 작업량이 n의 제곱에 비례하여 증가
  - 일반적으로 이중 반복문을 사용하는 경우
  - 2차원 배열의 모든 요소를 순회
  - 버블 정렬, 선택 정렬, 삽입 정렬 등

O(2^n) : 지수 시간
  - 알고리즘의 실행 시간이 입력 데이터 크기에 대한 2의 거듭제곱으로 증가
  - 일부 재귀 알고리즘에서 이 복잡도를 가짐
  - 문제를 더 작은 서브 문제로 나누지 않는 경우에 해당
  - 피보나치 수열의 재귀적 계산

O(n!) : 팩토리얼 시간
  - 알고리즘의 실행 시간이 입력 데이터 크기의 팩토리얼에 비례하여 증가
  - 매우 비효율적
  - 모든 가능한 경우의 수를 나열해보아야하는 문제에서 나타남

공간 복잡도(Space Complexity)
  - 프로그램 실행 중 필요한 메모리의 양
  - 변수, 배열, 재귀 호출 스택 등이 차지하는 메모리를 계산함
  - 시간 복잡도가 얼마나 빠른지 확인하는 기준이라면, 공간 복잡도는 얼마나 적은 메모리로 문제를 해결할 수 있는지 확인하는 기준

공간 복잡도를 신경 써야 하는 경우
  - 메모리 제한이 있는 환경
  - 큰 데이터 처리
  - 재귀 알고리즘

공간 복잡도 계산 방법
  - O(1)
  - O(n)
  - O(log n)
  - O(n^2)
  - O(2^n)


JAVA 컬렉션 프레임워크
  - 데이터를 저장, 처리, 조작할 수 있는 다양한 클래스와 인터페이스를 제공
1. 배열
  - 고정된 크기의 연속적인 메모리 공간에 데이터를 저장
  - 빠른 인덱스 접근
  - 메모리 사용이 효율적
  - 크기 변경 불가
  - 크기를 예측하기 어려울 때 비효율적
2. 리스트
  - 순서가 있는 데이터의 집합, 크기 변경 가능
  - 데이터의 동적 추가, 삭제 용이
  - 순서 유지
  - 데이터 접근 속도가 배열보다 느림
3. Map
  - 키와 값의 쌍으로 데이터를 저장, 키는 중복 불가
  - 빠른 검색 및 접근
  - 키를 통한 데이터 관리
  - 순서 유지 불가(Hashmap)
  - 키의 중복 관리 필요
4. Set
  - 중복을 허용하지 않는 데이터 집합
  - 데이터 중복 방지
  - 집합 연산 지원
  - 순서 유지 불가
  - 인덱스 접근 불가
5. Stack
  - LIFO(Last In First Out) 구조의 데이터 집합
  - 후입선출 방식 관리
  - 후행 작업(backtracking)에 유용
  - 무작위 접근 불가
6. Queue
  - FIFO(First In First Out) 구조의 데이터 집합
  - 순서대로 데이터 처리
  - 데이터 스트림 처리에 적합
  - 무작위 접근 불가
7. Deque
  - 양방향 큐 구조로 데이터를 양쪽 끝에서 추가하거나 제거 가능
  - 양쪽 끝에서의 데이터 추가 및 제거 가능
  - 스택과 큐의 기능을 모두 지원
  - 특정 구현체(ArrayDeque 등)는 크기 조정 시 성능 저하 가능성 존재
